/**
 * @file /ecl_mobile_robot/include/ecl/mobile_robot/pose.hpp
 *
 * @brief Representation of the mobile robot pose.
 *
 * This could be done in one of two ways - as an eigen container, or using
 * an eigen container for storage. While the first is more convenient,
 * it exposes alot of vector interfaces we really must avoid using for
 * poses (e.g. vector addition doesn't make sense as pose addition since
 * you have to be careful with the angles). So we choose the second method.
 *
 * @date 20/05/2010
 **/
/*****************************************************************************
** Ifdefs
*****************************************************************************/

#ifndef ECL_MOBILE_ROBOT_POSE_HPP_
#define ECL_MOBILE_ROBOT_POSE_HPP_

/*****************************************************************************
** Includes
*****************************************************************************/

#include <ecl/errors/standard_exception.hpp>
#include <ecl/linear_algebra.hpp>
#include <ecl/geometry/angle.hpp>

/*****************************************************************************
** Namespaces
*****************************************************************************/

namespace ecl {

/*****************************************************************************
** Interface
*****************************************************************************/
/**
 * @brief Representation for the pose of a mobile robot.
 *
 * This class provides a c++ container like interface for the pose as
 * well as a few mathematical transforms applicable to poses and relative
 * poses.
 */
class Pose {
public:
	/*********************
	** C&D
	**********************/
	/**
	 * @brief Delegate construction to the base vector class.
	 *
	 * This just passes the parameters through to the underlying container
	 * class while also ensuring the heading angle is wrapped to an
	 * appropriate value [-pi,pi].
	 *
	 * @param x : x value of the robot's location.
	 * @param y : y value of the robot's location.
	 * @param heading : heading of the robot.
	 */
	explicit Pose(const double& x = 0.0, const double& y = 0.0, const double& heading = 0.0)
	{
		// explicit stops Pose auto converting to doubles! Important so the
		// operator << doesn't get confused.
		elements << x, y, wrap_angle(heading);
	}
	/**
	 * @brief Copy construct from any compatible eigen matrix type.
	 *
	 * Copy construct from any eigen matrix type compatible to Vector3d.
	 *
	 * This also ensures the heading angle is wrapped to an
	 * appropriate value [-pi,pi].
	 *
	 * @param other : another matrix type (will compile error if incorrect size).
	 * @tparam OtherDerived : any compatible eigen matrix type (comp. w/ Vector3d).
	 */
	template<typename OtherDerived>
	Pose(const linear_algebra::MatrixBase<OtherDerived>& other)
	{
		elements = other;
		wrap_angle(elements[2]);
	}
	virtual ~Pose() {}

    /*********************
    ** Assignment
    **********************/
    /**
     * Provides a comma initialisation facility. This initiates the comma initialiser
     * with an iterator to the underlying elements and then leaves the initialiser to
     * do the rest.
     *
     * @code
     * Pose p; // At this point it is initialised with default values.
     * p << 1.0,2.0,1.57;
     * @endcode
     *
     * Unfortunately, can't do an angle wrap check with this one, so take care
     * when using!
     *
     * @param value : the first of three points to enter.
     * @return CommaInitialiser : eigen's comma initialiser mechanism.
     */
	linear_algebra::CommaInitializer< linear_algebra::Vector3d > operator<<(const double &value) {
		return elements.operator<<(value);
    }
	/**
	 * @brief Assignment operators from any compatible eigen matrix type.
	 *
	 * Assign from any eigen matrix type compatible to Vector3d.
	 *
	 * This also ensures the heading angle is wrapped to an
	 * appropriate value [-pi,pi].
	 *
	 * @param other : another matrix type (will compile error if incorrect size).
	 * @tparam OtherDerived : any compatible eigen matrix type (comp. w/ Vector3d).
	 */
	template<typename OtherDerived>
	void operator=(const linear_algebra::MatrixBase<OtherDerived>& other) {
		elements = other;
		wrap_angle(elements[2]);
	}
	/*********************
	** Setters
	**********************/
	void x(const double& value) { elements[0] = value; } /**< @brief Sets the x-coordinate. **/
	void y(const double& value) { elements[1] = value; } /**< @brief Sets the y-coordinate. **/
	void heading(const double& value) { elements[2] = wrap_angle(value); } /**< @brief Sets the heading. **/

	/**
	 * @brief Simple auto-conversion to the eigen vector format.
	 */
	operator const ecl::linear_algebra::Vector3d&() {
		return elements;
	}

	/*********************
	** Accessors
	**********************/
	/**
	 * @brief Representation in eigen vector format.
	 *
	 * Converts representation to an eigen vector reference - oft
	 * necessary in mathematics calculations.
	 * @return Vector3d : a reference to the underlying storage container.
	 */
	linear_algebra::Vector3d& vector() { return elements; }

	/**
	 * @brief Representation in const eigen vector format.
	 *
	 * Converts representation to a const eigen vector reference - oft
	 * necessary in mathematics calculations.
	 *
	 * @return Vector3d : a reference to the underlying storage container.
	 */
	const linear_algebra::Vector3d& vector() const { return elements; }

	/**
	 * @brief Returns a constant reference to the x co-ordinate.
	 *
	 * @todo This is not returning a const reference right now since
	 * Eigen 2.0.11 doesn't return const references. This will be
	 * fixed sometime in the future - change it back to refs then.
	 *
	 * @return double : x value.
	 */
	double x() const { return elements[0]; }
	/**
	 * @brief Returns a constant reference to the y co-ordinate.
	 *
	 * @todo This is not returning a const reference right now since
	 * Eigen 2.0.11 doesn't return const references. This will be
	 * fixed sometime in the future - change it back to refs then.
	 *
	 * @return double : y value.
	 */
	double y() const { return elements[1]; }
	/**
	 * @brief Returns a constant reference to the heading.
	 *
	 * @todo This is not returning a const reference right now since
	 * Eigen 2.0.11 doesn't return const references. This will be
	 * fixed sometime in the future - change it back to refs then.
	 *
	 * @return double : heading value.
	 */
	double heading() const { return elements[2]; }
	/**
	 * @brief Returns a copy of the x co-ordinate.
	 *
	 * @return double : x value.
	 */
	double x() { return elements[0]; }
	/**
	 * @brief Returns a copy of the y co-ordinate.
	 *
	 * @return double : y value.
	 */
	double y() { return elements[1]; }
	/**
	 * @brief Returns a copy of the heading angle.
	 *
	 * @return double : heading value.
	 */
	double heading() { return elements[2]; }

	/**
	 * @brief Accesses the pose, array style.
	 *
     * @exception : StandardException : throws if index is out of range [debug mode only].
	 *
	 * @param index : index of the array to index.
	 * @return double : value of the element indexed.
	 */
	double& operator [](const unsigned int& index) assert_throw_decl(StandardException) {
        assert_throw( index<3, StandardException(LOC,OutOfRangeError));
        return elements[index];
    }

	/**
	 * @brief Accesses the pose with a const constraint, array style.
	 *
     * @exception : StandardException : throws if index is out of range [debug mode only].
	 *
	 * @todo This is not returning a const reference right now since
	 * Eigen 2.0.11 doesn't return const references. This will be
	 * fixed sometime in the future - change it back to refs then.
	 *
	 * @param index : index of the array to index.
	 * @return double : value of the element indexed.
	 */
	double operator [](const unsigned int& index) const assert_throw_decl(StandardException) {
        assert_throw( index<3, StandardException(LOC,OutOfRangeError));
        return elements[index];
    }

	/**
	 * @brief Determines the differential, or relative pose.
	 *
	 * Depending on your perspective, this can be thought of as finding the
	 * <i>differential</i> pose, but more correctly it should be thought of
	 * as the <i>relative</i> pose. Given the specified pose a, this
	 * returns the pose of 'this object relative to a'. This is commonly used to
	 * find a differential pose between updates.
	 *
	 * @code
	 * Pose a(1.0,2.0,0.0);
	 * Pose b(1.0,3.0,3.14);
	 * Pose diff = b - a; // [ 0.0, 1.0, 3.14 ]
	 * a << 0.0, 0.0, 0.78;
	 * b << 1.0, 1.0, 0.78;
	 * diff = b - a; // [ sqrt(2), 0.0, 0.00 ]
	 * @endcode
	 *
	 * @param a : pose (wrt common/global frame).
	 * @return Pose : differential, or relative pose (wrt this pose's frame).
	 */
	Pose operator-(const Pose &a) const;
	/**
	 * @brief Determines the differential, or relative pose.
	 *
	 * This is a static version of the operator- variant.
	 *
	 *
	 * @code
	 * Pose a(1.0,2.0,0.0);
	 * Pose b(1.0,3.0,3.14);
	 * Pose diff = b - a; // [ 0.0, 1.0, 3.14 ]
	 * diff = Pose::Difference(a,b); // same thing.
	 * @endcode
	 *
	 * @param a : initial pose (wrt common/global frame).
	 * @param b : final pose (wrt common/global frame).
	 * @return Pose : differential, or relative pose (wrt a's frame).
	 */
	static Pose Difference(const Pose &a, const Pose &b) {
		return b - a;
	}

	/**
	 * @brief Adds the differential, or relative pose (wrt this pose).
	 *
	 * Depending on your perspective, this can be thought of as adding the
	 * <i>differential</i> pose, but more correctly it should be thought of
	 * as adding the <i>relative</i> pose. This is commonly used to
	 * update poses in mobile robotics.
	 *
	 * Returns the updated pose wrt common/global coordinates.
	 *
	 * @code
	 * Pose a << 0.0, 0.0, 0.78;
	 * Pose b << 1.0, 1.0, 0.78;
	 * Pose diff = b - a;        // [ sqrt(2), 0.0, 0.00 ]
	 * b_dash = a + diff;        // b_dash == b
	 * @endcode
	 *
	 * @param rel_pose : differential (wrt this pose's frame).
	 * @return Pose : this pose combined with rel_pose (wrt common/global frame).
	 */
	Pose operator+(const Pose &rel_pose) const;
	/**
	 * @brief Adds the differential to the current pose.
	 *
	 * Works similarly to the operator+ method, rather applies the differential
	 * to the current pose rather than a new object.
	 *
	 * @code
	 * Pose a << 0.0, 0.0, 0.78;
	 * Pose b << 1.0, 1.0, 0.78;
	 * Pose diff = b - a;        // [ sqrt(2), 0.0, 0.00 ]
	 * a += diff;                // a == b
	 * @endcode
	 *
	 * @param rel_pose : differential (wrt this pose's frame).
	 * @return Pose& : handle to the updated pose (wrt common/global frame).
	 */
	Pose& operator+=(const Pose &rel_pose);

	/**
	 * Insertion operator for sending the pose to an output stream. This
	 * is raw, and has no formatting.
	 * @param ostream : the output stream.
	 * @param pose : the pose to be inserted.
	 * @return OutputStream : continue streaming with the updated output stream.
	 */
	template <typename OutputStream>
	friend OutputStream& operator<<(OutputStream &ostream , const Pose &pose);

private:
	linear_algebra::Vector3d elements;

};


/*****************************************************************************
** Implementation [Streaming]
*****************************************************************************/
template <typename OutputStream>
OutputStream& operator<<(OutputStream &ostream , const Pose &pose) {
	ostream << "[ " << pose.x() << " " << pose.y() << " " << pose.heading() << " ]";
	return ostream;
}

} // namespace ecl

#endif /* ECL_MOBILE_ROBOT_POSE_HPP_ */
